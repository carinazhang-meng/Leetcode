# 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
## 示例1
>输入: [0,1,3]
>输出: 2
## 示例2
>输入: [0,1,2,3,4,5,6,7,9]
输出: 8
# 限制:1 <= 数组长度 <= 10000

## 弯路：当使用暴力求解法时，无法将问题答案考虑的完全，因此会有各种错误

## 用二分法是不错的思路，排序数组中的搜索问题，首先想到用二分法解决。
>数组按规则分为两部分，右子数组：nums[i]=j;左子数组：nums[i]!=j
### 算法解析

1.初始化： 左边界 i = 0，右边界 j = len(nums) - 1 ；代表闭区间 [i, j][i,j] 。

2.循环二分： 当 i <=j时区间为空，跳出 ；
计算中点 m = (i + j) // 2 ，其中 "//" 为向下取整除法；
若 nums[m] = m  ，则 “右子数组的首位元素” 一定在闭区间 [m + 1, j] 中，因此执行 i = m + 1；
若 nums[m] ！
 =m ，则 “左子数组的末位元素” 一定在闭区间 [i, m - 1] 中，因此执行 j = m - 1；

3.返回值： 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。
### 具体代码
 class Solution:
 
    def missingNumber(self, nums: List[int]) -> int:
        i, j = 0, len(nums) - 1
        while i <= j:
            m = (i + j) // 2
            if nums[m] == m: i = m + 1
            else: j = m - 1
        return i

